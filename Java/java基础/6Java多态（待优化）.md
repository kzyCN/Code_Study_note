# 多态

> 多态是同一个行为具有多个不同表现形式或形态的能力

==父类引用指向子类对象==

```java
父类名称 对象名 = new 子类名称
接口名称 对象名 = new 实现类名称
```

### 多态的优点

- 消除类型之间的耦合关系
- 可替换性
- 可扩充性
- 接口性
- 灵活性
- 简化性

### 多态存在的三个必要条件

- 继承
- 重写
- 父类引用指向子类对象

### 多态的好处

可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。

## 多态的实现方式

### 方式一：重写（Override）

### 方式二：接口

- \1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。
- \2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看Java接口这一章节的内容。

### 方式三：抽象类和抽象方法

详情请看==**Java抽象类**==章节。

## 对象的向上转型

### 格式

```java
父类名称 对象名 = new 子类名称();
```

==**含义：**==右键创建一个子类对象，把它当父类来看待使用

**向上转型一定是安全的。**从小范围转向大范围

**对象一旦向上转型为父类，那么就无法调用子类原本持有的内容**

向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。

## 对象的向下转型

**格式**

```java
子类名称 对象名 = （子类名称）父类对象；
```

==**含义：**==将父类对象【还原】成为原来的子类对象

```java
Animal animal = new Cat();//本来是猫，向上转型成为动物
Cat cat = (Cat) animal;//本来是猫，已经被当作动物了，还原成为本来的猫
```

**注意：**

1. 必须保证对象本来创建的时候，就是猫，才能向下转型成为猫
2. 如果对象创建的时候本来就不是猫，非要向下转型成猫，就会报错

向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用 `instanceof` 运算符来避免出此类错误。

## 如何才能知道一个父类引用的对象，本来是什么子类

**格式：**

```java
对象 instanceof 类名称
```

这将会得到一个`boolean`值结果，也就是判断前面对象能不能当作后面类型的实例

# 抽象类

> 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。
>
> 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
>
> 由于抽象类不能实例化对象，所以**抽象类必须被继承**，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
>
> 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
>
> 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。

### 抽象类定义

抽象类在`class`前面加上`abstract`即可

### 抽象类的使用

1. 不能直接创建抽象类对象。
2. 必须用一个子类来继承父类。
3. 子类必须覆盖重写抽象类当中的所有抽象方法。
4. 创建子类对象进行使用。

### 抽象方法

抽象方法在返回值前面加上**abstract**关键字，然后去掉大括号，直到分号结束。

声明抽象方法会造成以下两个结果：

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

# 内部类

> 如果一个事物包含另一个事物，那么这就是一个内部类包含另一个类

### 分类：

1. 成员内部类
2. 局部内部类（包含匿名内部类）

### 定义格式

```Java
修饰符 class 类名称{
    修饰符 class 内部类名称{
    }
}
```

###  注意：

内用外，随意访问

外用内，需要内部类

### 如何使用成员内部类？有两种方式

1. 间接方式：在外部类的方法中，使用内部类；main只是调用外部类的方法

2. 直接方式：

   ```JAVA
   外部类名称.内部类名称 = new 外部类名称().new 内部类名称();
   ```

---

## 局部内部类

> 如果一个类定义在一个方法内部，那么这就是一个局部内部类了

局部：只有当前所属的方法才能使用它，出了这个方法外面就无法使用了

### 定义格式：

``` java
修饰符 class 外部类名称{
    修饰符 返回值类型 外部类方法名称（参数列表）{
        class 局部内部类名称{}
    }
}
```

---

# 匿名内部类

> 如果接口的实现类（或者父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而使用【匿名内部类】

定义格式：

```java
接口名称 对象名 = new 接口名称（）{
    //覆盖重写所有抽象方法 @Override
}
```

### 注意：

1. 匿名内部类，在创建对象时，只能使用唯一的一次。如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。
2. 匿名对象，在调用方法的时候，只能调用唯一一次。如果希望同一对象，调用多次方法，那么必须给对象起个名字。

---

# 接口

> 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
>
> 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
>
> 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
>
> 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。

**接口就是一种公共的规范标准，是多个类的公共规范**

**接口是一种引用类型，最重要的就是其中的抽象方法**



## 接口与类相似点

- 一个接口可以有多个方法。
- 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
- 接口的字节码文件保存在 .class 结尾的文件中。
- 接口相应的字节码文件必须在与包名称相匹配的目录结构中。

## 接口与类的区别

- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

## 接口特性

- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。

## 抽象类和接口的区别

- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。
- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
- 一个类只能继承一个抽象类，**而一个类却可以实现多个接口**。

## 接口的声明

```java
public interface 接口名称{
    //接口内容
}
```

**接口的抽象方法必须有两个固定关键字`public abstract`**

## 接口可以包含

1. 常量
2. 抽象方法
3. 默认方法
4. 静态方法
5. 私有方法

## 接口的实现

当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。

类使用implements关键字实现接口。

在类声明中，Implements关键字放在class声明后面。

```JAVA
public class 实现类名称 implements 接口名称{}
```

接口的实现类必须覆盖重写，加上方法体大括号



## 接口的默认方法

> 接口的默认方法，可以解决接口的升级问题

### 默认方法的声明

```java
public default 返回值类型 方法名称（参数列表）{}
```

1. 接口的默认方法，可以通过接口的实现类对象直接调用。
2. 接口的默认方法，也可以被接口实现类进行重写



## 接口的静态方法（从Java 8开始）

```Java
public static 返回值类型 方法名称（参数列表）{}
```

- 不能通过接口的实现类来调用接口当中的静态方法
- **正确用法**：通过接口名称，直接调用其中的静态方法`接口名称.静态方法（参数）`



## 接口的私有方法（从Java 9开始）

> 接口的私有方法一般用来解决两个默认方法之间的代码重复问题

1. 普通私有方法

```java
private 返回值类型 方法名称{}
```

2. 静态私有方法

```java
private static 返回值类型 方法名称{}
```

## 接口的常量

```java
public static final 数据类型 常量名称 = 数据值；
```

**接口中的常量，必须进行赋值，不能不赋值**

## 接口之间的多继承

1. 一个类的直接父类是唯一的，但是一个类可以实现多个接口

```java
public class 名称 implements 接口A，接口B{
    //覆盖重新所有抽象方法
}
```

2. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可
3. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么类就必须是一个抽象类
4. 如果实现类所实现的多个接口中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
5. 一个类如果有父类当中的方法，和接口当中的默认方法产生冲突，优先使用父类方法





